给定一个字符串，找出不含有重复字符的最长子串的长度。

示例 1:

输入: "abcabcbb"
输出: 3 
解释: 无重复字符的最长子串是 "abc"，其长度为 3。
示例 2:

输入: "bbbbb"
输出: 1
解释: 无重复字符的最长子串是 "b"，其长度为 1。
示例 3:

输入: "pwwkew"
输出: 3
解释: 无重复字符的最长子串是 "wke"，其长度为 3。
     请注意，答案必须是一个子串，"pwke" 是一个子序列 而不是子串。


//自己的思考:   错误的。。。
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        //给定一个字符串s，返回一个整型数字（不含有重复字符的最长字串的长度）
        //那我们从字符串的第一个字符开始，一直遍历到'/0'
        //问题是怎么访问字符串的第一个字符：s[0],即字符串第一个字符
        
        int i = 0;
        int j = i + 1;
        int num = 1;
        int maxnum = num;   //不含有重复字符的最长字串长度为maxnum
        while (s[i] != '/0'){
            while (i < strlen(s.c_str()) && s[j] != s[i] && s[j] != '/0'){ //我比较了第二个不等于第一个，第三个只和第二个比较一下就行了，不用跟第一个再比
                                                    //strlen(s) 是字符串s的字符个数，不包括结尾的/0，注意下标从0开始，所以是到strlen(s)-1
            
                
            /*注意，这里使用strlen错误，
            s是一个std::string类型的变量，而strlen要求的参数是char*类型的
　　         如果要获取s字符串的长度，std::string自带一个size接口可以满足需求，即int i = s.size()
如果仍要继续使用strlen，则可以使用std::string的c_str接口。该接口返回一个const char*指针，正好可以作为参数传递给strlen,也就是i = strlen(s.c_str())
            */
            
                
                num++;                              //从0开始，第二个字符不等于第一个字符，那么num++
                i++;
            }
            i++;
            if(num > maxnum)
                maxnum = num;
            num = 0;  
        }
        return 0;   
    }
};


网上的方法：
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        /********
        一个字符一个字符的遍历，比如a，b，c，然后又出现了一个a，那么此时就应该去掉第一次出现的a，然后继续往后，又出现了一个b，则应该去掉一次出现的b，以此类推，最终发现最长的长度为3。所以说，我们需要记录之前出现过的字符，记录的方式有很多，最常见的是统计字符出现的个数
        ********/
        
        //采用哈希表方法：
        //哈希表是一种根据关键码去寻找值的数据映射结构，key-value，字典结构
        /*给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。*/
        
        /********
        建立一个256位大小的整型数组来代替哈希表，这样做的原因是ASCII表共能表示256个字符，所以可以记录所有字符，然后我们需要定义两个变量res和left，其中res用来记录最长无重复子串的长度，left指向该无重复子串左边的起始位置，然后我们遍历整个字符串，对于每一个遍历到的字符，如果哈希表中该字符串对应的值为0，说明没有遇到过该字符，则此时计算最长无重复子串，i - left +１，其中ｉ是最长无重复子串最右边的位置，left是最左边的位置，还有一种情况也需要计算最长无重复子串，就是当哈希表中的值小于left，这是由于此时出现过重复的字符，left的位置更新了，如果又遇到了新的字符，就要重新计算最长无重复子串。最后每次都要在哈希表中将当前字符对应的值赋值为i+1。
        *******/
        
        int m[256] = {0};  
        //建立一个256位大小的数组来存放ASCII的256个字符，全部初始化为0，也就是m[1] = m[&] = m[a] = m[b] = ... = 0,这里的1是ASCII字符
        //这个m[256]，我们可以叫他哈希表
        
        int maxnum = 0,left = 0;  //maxnum是最后要返回的最长字符串长度。 left是无重复字符串最左边的起始位置
        //拿"abcabcbb"举例：
        for (int i = 0;i < s.size();++i){             //s.size()返回字符串字符个数，这里为什么用++i
            if (m[s[i]] == 0 || m[s[i]] < left){      //s[0] = a, m[a] = 0  或者  m[a] = 0 < left = 0
                maxnum = max(maxnum, i - left + 1);//这里直接采用了STL算法中的max函数，返回两个数中的最大数。i - left + 1是无重复字符串的字符长度
            }
            else                    //只要不出现重复字符，left标志就不变动
                left = m[s[i]];    //如果出现了重复字符（也就是m[某个字符] != 0），那么左标志就变成当前字符位置，也就是第四个位置处的a，
            m[s[i]] = i + 1;       //遍历一遍之后，m[a] = 1
        }   
        
        /********
        "abcabcbb"
        这个循环是这样执行的：
        首先i=0,因为m[a]=0,所以maxnum=1,m[a]=1
        然后i=1,因为m[b]=0,所以maxnum=2,m[b]=2
        然后i=2,因为m[c]=0,所以maxnum=3,m[c]=3
        然后i=3,因为m[a]=1,所以left=m[a]=1,m[a]=4
        然后i=4,因为m[b]=2,所以left=m[b]=2,m[b]=5
        然后i=5,因为m[c]=3,所以left=m[c]=3,m[c]=6
        然后i=6,因为m[b]=5,所以left=m[b]=5,m[b]=7
        然后i=7,因为m[b]=7,所以left=m[b]=7,m[b]=8
        然后i=8，i=8 !< s.size()=8,所以结束for循环
        *********/
        
        //最后返回maxnum = 3
        return maxnum;    
        
        
        /********
        另一个例子：
        "abbca"
        这个循环是这样执行的：
        首先i=0,因为m[a]=0,所以maxnum=1,m[a]=1
        然后i=1,因为m[b]=0,所以maxnum=2,m[b]=2
        然后i=2,因为m[b]=2,所以left=m[b]=2,m[b]=3
        然后i=3,因为m[c]=0,所以maxnum=(2,3-2+1)=2,m[c]=4
        然后i=4,因为m[a]=1,但是m[a]=1 < left=2,所以maxnum=(2,4-2+1)=3,m[a]=5
        然后i=5,因为i=5 !< s.size()=5,所以结束for循环
        *********/ 
        }
};

